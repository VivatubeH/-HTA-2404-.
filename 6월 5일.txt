SI, SM, 자사 서비스 회사 기타 등등...

수료하면 포트폴리오나 자격증 준비하는 것도 soso...

수행문을 작성하면, 수행문은 반드시 메소드 안에 포함되어 있어야 한다.

메소드 : 특정한 작업을 수행하기 위한 수행문들을 하나의 이름으로 묶어놓은 것.
[ 객체의 구성 요소 중 기능을 담당 ] [ 선언부와 구현부로 구성됨 ]

자바 가상머신은 무조건 main이라는 메서드 안에 적어놓은 수행문을 수행함.

메서드 이름이 있어야 호출 및 재사용이 가능함.

호출 - 메서드의 기능을 수행하는 작업 

메소드의 구성 
- 반환타입 : 메소드 실행 후 최종적으로 획득되는 값의 타입.
메소드가 값을 반환한다 = 변수에 담을 수 있는 값을 제공해 줄 때.

[ 반환타입의 종류 
1. void인 경우 : 해당 메서드는 값을 반환하지 않음. ( 결과를 담을 수 없음 )
[ 메소드가 추가/변경/삭제 작업을 수행하는 경우 ]
[ 메소드가 출력작업을 수행하는 경우 ]

2. void가 아닌 경우 : 값을 획득할 수 있음, 값을 받기 위해 return이 있어야 하고
어떤 타입의 값을 반환할 지 반환타입 자리에 표시를 해야함.
[ 메소드가 조회 작업을 수행하는 경우 ]
[ 메소드가 계산 작업을 수행하고, 계산 결과를 제공하는 경우 ]
[ 메소드가 입력값에 대한 변환작업을 수행하고, 변환 결과를 제공하는 경우 ] 

메서드가 값을 반환하려면 반드시 return이 있어야 한다.

반환타입 메소드이름(매개변수타입 매개변수, 매개변수타입 매개변수, ...) {
  수행문;
  수행문;
  수행문;
}

매개변수(parameter) : 특정 작업을 수행하는 데 필요한 값
[ 메소드는 매개변수를 0개 이상 정의할 수 있다. ]
[ 메소드의 매개변수가 여러 개이면 ,로 구분한다. ]
[ 매개변수가 정의된 메소드 실행시 타입 순서 및 개수를 일치시켜야 한다. ]
[ 반환타입이 void가 아닌 경우에는 메소드의 수행문에는 반드시 값을 반환하는 
return 문이 있어야 한다. ]

/** 입력하고 해당 클래스나 메서드 위에서 엔터 누르면 자바 doc 주석 달 수 있음

입력할 때 그냥 ctrl + space로 입력하자...

값을 반환하지 않는 메서드는 출력에 이용할 수 없음.

메소드를 만드는 이유 - 호출을 통해 프로그램 안에서 반복적으로 사용 가능.

접근제한자 - 클래스 내에서 멤버의 접근을 제한한다.
1. public - 접근 제한을 하지 않는 전체 공개.
2. private - 외부 접근 차단 [ 전체 차단 ]
protected, default는 나중에 배움

접근 제한 대상
클래스 - public , default [ 일반적으로 public ]
필드 - public , protected, default, private [ 필드는 웬만하면 private으로... ]
생성자 - public, protected, default, private [ 대부분 다 공개함. public ]
메소드 - public, protectd, default, private 

즉, 기능은 공개하고 속성은 감추는 게 객체지향 프로그램의 원칙임.
[ 공개된 기능을 통해서 간접적으로 속성에 접근한다. ]

메서드 중복 정의 - 매개변수의 개수나, 매개변수의 타입이 다르면 가능함.
[ 목적 : 비슷한 작업은 일관된 이름으로 수행하기 위해서 ]
[ 하나의 클래스 안에 같은 이름의 메소드를 여러 개 정의하는 것 ]
[ 반환타입은 상관 없음. ]
[ 개발자든 사용자든 이름을 많이 쓸 필요가 없어서 유용한 기능 ]

private으로 설정해놓으면 외부에서 아예 확인 조차 안된다.
( 이클립스로 위에 올려놔도 설명에서 안 나옴 )

메소드 명은 동사형으로 짓는 게 기본이고 이름만 봐도 유추 가능해야 함.

String.valueOf()를 사용하면 () 안의 내용을 문자열로 변환시켜준다.

디버그 모드로 breakpoint를 설정하면 실행이 breakpoint에서 멈춰있다. 

변수명이나 메서드명 클래스명 등 이름만 보고 유추할 수 있도록 해야하고,
그를 보충하기 위해서 /** 을 이용해서 javadoc을 작성한다.

로직이 너무 복잡해지지 않게 나쁜 경우를 찾아서 빠르게 종료시키는 방법이 있음.
[ 최악의 경우를 먼저 찾고, 즉시 return으로 종료시키자 ]
[ 조건이 평면적으로 나열되도록 작성하자 ]
[ 즉, 나쁜 경우를 찾아서 빨리 함정에 빠뜨리자 . 이렇게 작성하면 새로운 조건 
추가시에도 별도로 함정만 하나 더 파면 된다. ]

return의 2가지 용도
1. 값을 반환함
2. 메서드의 실행을 즉시 종료함

public void changePassword(String no, int prevPwd, int pwd) {

if (accNo != no) {
System.out.println("계좌번호가 일치하지 않습니다.");
return;
} 

if (password != prevPwd) {
System.out.println("비밀번호가 일치하지 않습니다.");
return;
}

if (prevPwd == pwd) {
System.out.println("이전 비밀번호와 같은 비밀번호로 변경할 수 없습니다.");
return;
}

password = pwd;
System.out.println("비밀번호 변경이 완료되었습니다.");
}

// 로직은 위처럼 작성하자.. 

나쁜 경우가 있는 경우, 나쁜 경우가 없는 경우가 있는데
나쁜 경우를 찾아서 고칠 수 있다.

모든 수행문은 return문 뒤에 사용 불가임.
[ return문은 항상 메서드의 맨 끝에 있어야 함 ]

메소드 생성을 하려면 요구 조건의 정확한 분석이 가장 중요함.

프로그램 개발은 결국 기능을 구현해야 함.

생성자(Constructor) : 객체가 제대로 된 모양을 구축하게 해줌.
[ ★ 객체를 초기화하는 데 사용됨. ★ ] 
[ 생성자는 아주 특별한 메소드임
- 생성자는 무조건 클래스 이름과 동일한 이름을 가짐 
- 반환타입이 없음. [ void도 안 적음 ]
- 객체가 생성되자마자 실행할 작업을 구현해놓은 메소드.
] 

생성자 메소드의 사용
- new 연산자로 객체를 생성할 때 사용한다.
- Sample s1 =new Sample(); // 기존에 이렇게 적었을 때 Sample()이 생성자 메소드였다.

생성자 메서드는 만들지 않아도 자동으로 추가된다.
[ 사용자가 정의하지 않아도 언제나 추가됨. ] [ 컴파일 과정에서 .class를 만들때 ]

생성자의 실행 
- 생성자 메서드는 new 키워드와 같이 사용된다.
[ 객체가 생성된 후에 참조변수로 생성자 메소드를 다시 실행할 수는 없다. ]
[ new 키워드로 객체를 생성할 때, 그 때만 실행된다. ] 
[ 생성자 메소드명이 클래스명과 동일하므로 new 키워드는 생성자 이름과 동일한
이름의 클래스로 객체를 생성할 수 있다. ]

생성자 메소드를 통해 JVM에게 두 가지 정보를 전달할 수 있다.
1. 객체 생성에 쓰일 클래스명 <--- 생성자 메소드 이름이 클래스 이름이다.
2. 객체 생성 직후에 실행할 메서드.

new 연산자로 생성자를 사용하면 항상 생성한 객체의 주소값을 반환하므로
생성자 메서드는 반환타입이 필요없음.

기본 생성자 메소드 ( default constructor )
- 매개변수가 하나도 없는 생성자 메소드. 

생성자 메소드에 포함된 코드는 객체 실행 직후에 실행이 된다.

일반적으로 생성자 메서드가 하는 일은 멤버 변수를 초기화하는 일을 한다.

객체를 생성한 이후에는 일반 메서드만 실행 가능함.
( 생성자 메서드 실행은 불가능함. )

생성자 메서드도 메서드이니 매개변수가 다르다면, 메서드 중복 정의가 가능하다.

기본 생성자 메서드가 추가되는 경우는 생성자가 하나도 없을 때 뿐임.
[ 즉, 다른 생성자가 하나라도 있으면 기본 생성자를 추가하지 않는다. ]

이클립스 여러 줄 주석 처리 : ctrl + shift + /
이클립스 여러 줄 주석 해제 : ctrl + shift + \ 

일반 메서드로 초기화를 화면 초기화 횟수에 제한을 걸 수가 없다...



