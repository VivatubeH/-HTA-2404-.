## 1. Java의 특징
자바는 기존의 절차적 프로그래밍이 갖는 단점을 줄이기 위해 객체지향 프로그래밍 방식으로 개발되었다.
객체지향 프로그래밍의 가장 중요한 한 단어는 <mark>'객체'</mark>라고 할 수 있을 것이다.   
자바의 대표적인 특징은 객체지향이 갖는 특징과도 일치한다고 볼 수 있을 것이다.

객체는 사물(Object)이다. 즉, 세상에 존재하는 모든 것은 객체이다. 각 객체들은 고유하며 속성을 갖고 행위를 한다.   
이 때의 속성은 property, 행위를 method로 할 수 있을 것이다.   

<mark>개발자에게 유지보수, 개발 효율성, 재사용성, 정보 은닉의 장점을 도대체 어떻게</mark> 객체지향은 제공할까?

이러한 장점을 제공하는 가장 큰 주체는 바로 <mark>'클래스'</mark>이다.

예를 들어 자동차라는 객체를 만든다고 해보자. 바퀴, 창문, 핸들, 문, 트렁크 등의 '속성'이 있고   
전진, 후진, 와이퍼 작동, 기어 변속 등의 기능이 있다.

만약 자동차를 1대 만들어야 한다면? 그냥 작성하면 될 것이다. 근데 자동차를 1만대, 1억대 만든다고 생각해보면 매번 코드를 작성하는 건
너무나도 비효율적일 것이다. 그래서 객체지향에서는 클래스에 속성과 기능을 담고 똑같은 객체를 찍어낼 수 있게 했다.   

이러한 클래스를 활용한다면 무슨 일이 일어날까?   

만들어야 할 차 대수가 늘어난다? <strong>그냥 클래스(설계도) 가져다가 객체(자동차)만 찍어내면 된다.</strong>   
랜덤으로 자동차가 고장난다면? <strong>어떤 차인지 찾을 필요 없이, 그냥 클래스(설계도)만 수정하면 된다. </strong>   
자동차가 달리는 원리를 모른다면? <strong>몰라도 된다. 그냥 엑셀만 누르자.</strong>

이러한 모든 게 클래스 하나를 통해 가능한 것이다. 이게 바로 자바의 특징이자 객체지향의 특징이다.

## 2. JDK vs JRE
JDK(Java Development Kit)은 자바를 <mark>개발</mark>하는 데 쓰이고, JRE는 자바를 <mark>실행</mark>하는 데 쓰인다.   
JRE에서 자바 개발 도구들이 포함된 것이 JDK이므로 먼저 JRE에 대해 알아보자.

#### 2-1. JRE의 2가지 요소
첫 번째로, Java Runtime Environment/자바 실행 환경인 만큼 자바를 실행하는 데 필요한 <mark>JVM(자바 가상 머신)</mark>이 필수로 있어야 한다.   
두 번째로는 <mark>개발자가 사용한 라이브러리</mark>를 알아야 실행할 수 있으므로 자바 라이브러리들도 포함된다.

#### 2-2. JDK의 핵심 요소
JDK는 자바 개발 도구인 만큼 말 그대로 개발 도구들이 포함된다.   
자바 문서를 만드는 Javadoc, 소스를 바이트 코드로 컴파일할 javac, 디버깅에 사용할 JDB(Java Debugger)가 대표적이다.

## 3. Java 실행방식
자바의 실행은 JVM이라고 불리는 자바 가상 머신이 담당한다.   
JVM은 자바 코드를 직접 실행하는 것이 아닌, 컴파일러에 의해 변환된 바이트 코드를 실행한다.   

바이트 코드(Bytecode)는 고급 언어로 작성된 자바 코드를 가상 머신이 이해할 수 있는 중간 코드로 컴파일한 것을 말한다.   
가상 머신은 이러한 바이트 코드(.class)를 운영체제에 맞는 바이너리 코드(이진코드)로 변환후에 실행하게 된다.

![image](https://github.com/user-attachments/assets/357134bb-6b0c-4172-833b-0b0c4c42ea57)


## 4. 인터프린터 언어 vs 컴파일 언어
자바스크립트와 파이썬은 인터프리터 언어, C와 C++은 컴파일 언어이다. 그렇다면 자바는 무슨 언어일까?   
정답은 자바는 컴파일과 인터프리터 언어에 모두 해당되는 언어이다.   

인터프리터와 컴파일러는 모두 <mark>고레벨 언어를 저레벨 언어인 기계어로 해석해주는 번역 프로그램</mark>이다.   
둘 다 고레벨에서 저레벌로의 해석이라면, 이 둘의 차이점은 뭘까?   

차이점은 바로 실행방식에 있다.   

컴파일러는 프로그램 전체를 읽은 후에 <mark>한 번에 기계어로 번역</mark>하게 된다.   
그래서 그만큼 초기 번역시간은 오래 걸리지만, 만들어놓은 실행파일을 계속 사용할 수 있으므로   
전체 실행시간은 인터프리터보다 빠르게 된다. 그러나 메모리 효율은 떨어진다.

인터프리터는 프로그램을 실행할 때 <mark>한 번에 한 문장</mark>씩만 기계어로 번역한다.   
그러다보니, 실행이 컴파일러보다 조금 더 느릴 수 있지만 별도의 실행파일은 필요없으므로 개발 속도는 빠르다.

## 5. Java가 플랫폼에 독립적인 이유
자바가 플랫폼에 독립적일 수 있는 이유는 앞에서 배웠듯, 가상 머신 덕분이다.   
자바를 이용해 작성한 코드를 컴파일러를 이용해 .class라는 바이트 코드로만 변환해 놓는다면
코드 실행이 JVM에 의해 각 운영체제에 맞게 실행되므로 플랫폼에 독립적일 수가 있다.
![image](https://github.com/user-attachments/assets/8713a247-8dd8-4ce2-bf55-7c385ef03e51)

## 6. JVM 구조
JVM은 Garbage Collector, Execution Engine, Class Loader, Runtime Data Area 크게 4가지로 나눌 수 있다.
![image](https://github.com/user-attachments/assets/d0e09641-e8fb-4ba9-a94a-190031274daa)

자바 컴파일러에 의해 변환된 클래스 파일을 <mark>Class Loader</mark>가 읽어들이면서 JVM이 시작된다.   
이후, 클래스 로더를 통해 읽어들인 코드를 <mark>Execution Engine</mark>이 명령어 단위로 읽어서 실행한다.   
실행될 때, 데이터와 명령어등은 JVM 메모리 영역인 <mark>Runtime Data Area</mark>에 할당된다.
메모리 영역의 관리는 <mark>Garbage Collector</mark>가 담당하게 된다.

## 7. 스레드 vs 프로세스
프로세스는 운영체제로부터 <strong>자원을 할당받은 작업의 단위</strong>   
스레드는 <strong>프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위</strong>이다.   

예를 들면, <mark>식사라는 하나의 프로세스</mark>가 존재한다고 해보자.   
쌀로 밥을 짓는다, 반찬을 만든다, 밥을 그릇에 푼다, 숟가락을 꺼낸다, 숟가락으로 밥을 푼다, 입에 넣는다, 씹는다, 소화시킨다 등등...   

이 때, 밥을 먹는다라는 하나의 프로세스는 <strong>밥 짓기, 밥 푸기, 숟가락 꺼내기</strong> 등등의 <mark>스레드</mark>로 구성되게 된다.   
만약 내가 <strong>손이 빨라서 밥을 지으면서 반찬을 만든다면</strong>? 이런 것들을 <mark>멀티스레드</mark>로 볼 수 있겠다.   

식사 프로세스, 공부 프로세스, 씻기 프로세스 등은 서로에게 영향을 미치지 않는다. 밥을 안 먹어도 씻을 수는 있다.   
이처럼 각각의 프로세스는 독립성이 존재한다.   

그러나, 밥 짓기 스레드, 숟가락 들기 스레드, 입에 넣기 스레드 중 하나라도 못하면? 당연히 밥을 못 먹는다.
이처럼 각각의 스레드는 서로 영향을 미칠 수 있다.
## 8. GC(**Garbage Collection)**
기존의 C나 C++에서는 개발자가 직접 메모리를 관리하는 코드를 작성해야만 했다.   
자바에서는 Garbage Collector를 통해서 <mark>Garbage Collection이라는 메모리 관리를 자동으로 수행</mark>할 수 있게 된다.   
즉, 메모리 누수와 같은 문제를 방지할 수 있게 된다. 단점이라면 개발자도 언제 메모리를 처리할 지 알지 못하므로 오버헤드가 발생한다.
