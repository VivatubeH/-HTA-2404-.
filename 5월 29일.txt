형변환 : 데이터 타입이 변하는 것.
[ 정수가 실수로 변하는 것처럼 . ]

형변환이 일어나는 경우. [ 데이터의 손실이 없을 때 ]
1) 크기가 작은 타입에서 크기가 큰 타입의 값으로 변하거나
2) 정밀도가 낮은 타입에서 정밀도가 높은 타입으로 변하거나

자바에서 연산은 항상 타입 일치후에 연산이 일어남.
[ 타입이 다르면 형변환을 통해 같은 타입으로 만든 후에 연산이 일어남. ]

[ 정수 / 정수 = 정수 ]
[ 실수 / 실수 = 실수 ]

기본 자료형에서의 형변환 대상은 숫자와 문자만 해당됨. [ boolean은 형변환 대상 x ]

[ 보통 정수보다는 실수가 정밀도가 높다고 봄. ( 소수점 아래까지 표현 가능해서 ) ]

수동 형변환 : 데이터의 손실을 감안하고 개발자가 형변환 연산자를 직접 지정해야 함.
[ 데이터의 손실 때문에 자동 형변환이 이루어지지 않을 때 사용 ]

수동 형변환 방법 
int a = (int)70.123; [ 이처럼 형변환 하고자 하는 타입을 괄호로 앞에 적어야 함 ]

대문자는 클래스 이름과 상수 외에는 항상 소문자만 사용함.
[ ★ 패키지 이름도 소문자임. 클래스 이름만 대문자 ]

이클립스에서 alt + 방향키를 하면 행을 옮겨 다닐 수 있음.

자동 형변환은 자바 문법이 자동으로 해주는 거임.

문자는 숫자에 저장할 수 있음. ( 유니코드로 저장되어 있기 때문 )
그러나, 
문자열은 숫자에 저장할 수 없음. ( 객체이기 때문 ) 

char 타입에 숫자를 담으면 자동으로 문자로 변환되고,
int 타입에 문자를 잡으면 자동으로 숫자로 변환됨.
[ int -> char 변환 시에는 범위 초과시 에러 발생 ]

나머지 연산자는 나누는 수보다 항상 더 작은 나머지가 나올 수 밖에 없음.
[ unixtime을 이용한 %6을 하면 0,1,2,3,4,5가 나오는데 +1 하면 1,2,3,4,5,6 이 나옴 ]

연산자는 우선 순위가 있음. 
[ int a = 10 + 2 일 때 +이 먼저 일어나고 =이 나중에 일어남 ]

자바에서 대입 연산자는 언제나 우선 순위가 가장 낮음.

증감 연산자 : ++, --는 변수의 값을 1증가시키거나 1감소시킬 때 사용함.
[ 증감 연산자는 단항연산자임. ( 변수에만 사용 가능 ) ]
[ 변수의 앞에 적어도 되고, 뒤에 적어도 되지만, 
증감 연산자는 단독으로 사용하지 않을 때는 순서를 신경 써야 함. ]

비교 연산자 : 두 값을 비교해서 결과를 항상 boolean 타입의 값으로 제공함.
[ 자바에서 =는 대입 연산자라서 값이 같은지 비교하려면 == 2번 사용 ]
[ 비교 연산자에서 항상 부등호 다음에 등호가 와야 하고 둘은 붙어 있어야 함 . ] 

논리 연산자 : 논리곱(&&), 논리합(||), 논리부정(!)
[ 둘 다 참일때만 참, 둘 중 하나만 참이면 참, boolean 값 반대로 ]

사칙연산 표기할 때, 연산자 우선순위에 맞게 붙여서 쓰면 좋음
[ * / %는 붙여서 적고 + - 는 띄워서 적는다. ] 

음수가 들어간 나눗셈은 부호를 빼고 계산 후 맞춰야 한다.
[ 정해진 규칙은 없는듯? ]

덧셈 연산자만 문자열이 들어가면 연결 기능이 생긴다.
[ 숫자 + 문자열 = 문자열 , 문자열 + 숫자 = 문자열 ]
[ 문자열이 들어간 덧셈은 문자열로 변환되어 이어붙여짐 ]


자바에서 long 타입을 int 타입으로 변환할 때 8바이트의 뒤쪽 4바이트를 사용함.
( 데이터 손실 방지를 위해서 )

복합 대입연산자는 우항에 있는 값으로 연산을 수행한 결과를 좌항에 대입함.
[ num1 += 10;은 num1에 10을 더한 값을 num1에 할당함. ]

프로그램은 업무로직을 처리하는 작업임.
업무로직 : 다양한 조건에 대한 검사를 수행하고, 검사결과가 true인지 false인지에
따라서 적절한 작업을 수행하는 것.

& - 앰퍼샌드 
| = 파이프

비교연산자는 한 가지 조건에 대한 검사만 수행 가능.
논리연산자는 2개 이상의 조건을 합쳐서 검사하기 위해 사용.

논리 연산자를 사용할 때,

논리합일 때는 T가 한 번이라도 나오면 그 뒤는 확인할 필요가 없고
논리곱일 때는 F가 한 번이라도 나오면 그 뒤는 확인할 필요가 없음.

제어문 : 특정 수행문이 수행되거나 수행되지 않도록 만드는 것.

변수의 값을 변경하는 코드와 논리 연산자를 같이 쓰지 않도록 한다.
[ 결과값에 영향을 미칠 수 있기 때문에 ] 
[ # 찾을 수 없는 오류를 발생시킬 수 있으니 쓰지말자. ]

삼항 연산자(조건 연산자 ) - 기본 형태는 [ 조건식 ? 값1 : 값2; ]
조건식이 true면 값1이 최종 결과, 조건식이 false면 값2가 최종 결과가 됨.
값1과 값2는 같은 타입이어야 함. [ 형변환이 가능하면 같지 않아도 됨. ]

조건 연산자로는 충분히 않으니, 제어문을 사용함.

비트 연산자의 연산 대상은 숫자임.

[ 추가 : 비트 연산 ( 몰라도 됨. )

4 & 3                                              4 << 2
00000100                                        00000100
00000011		            00010000 = 16

00000000 = 0

4 | 3
00000100
00000011

00000111 = 7

4 ^ 3
00000100
00000011

00000111 = 7

~4
00000100

11111011 = -5 
00000101 = 5 [ 더해서 0되는 수 찾기 ]

4 >> 2
00000100
00000001 = 1

-5 >>> 1 = 2147483645 
-5 >> 1 = -3 

] 몰라도 됨

int a = 3 , int b = 2일 때
int x = a*b로도 구할 수 있지만 int x = a << 1 로도 구할 수 있음.

특정한 값을 2의 배수만큼 늘려야 할 때는 시프트 연산을 쓰자.( 연산 속도가 빠름 )
[ 알고리즘 테스트에서 많이 사용됨. ]
[ 빠른 실행 속도가 필요한 작업 or 암호화가 필요한 작업에 많이 사용됨. ]

암호화를 할 때는 키가 필요하고, 복호화 할 때도 키가 필요한데.

암호화
   단방향 암호화 [ 주로 비밀번호를 저장하기 위한 용도로 사용 ]
      평문 ---> 암호문
      * 평문을 암호문으로 암호화하는 알고리즘이다.
      * 절대로 암호문을 다시 평문으로 복원할 수 없는 알고리즘이다.
   양방향 암호화
      평문 <---> 암호문
      * 평문을 암호문으로 암호화할 수 있고,
                  암호문을 다시 평문으로 복호화할 수 있다.
      * 암호화/복호화에는 키가 필요하다.
   
      - 대칭형 암호화 알고리즘
        * 암호화/복호화에 같은 키를 사용한다.
        * 암호화/복호화에 매번 다른 키를 사용하게 되면
                    복호화에 필요한 키를  네크워크를 통해서 상대방에게 전송해야 한다.
        * 보안에 취약하다.
      - 비대칭형 암호화 알고리즘
        * 암호화/복호화에 서로 다른 키를 사용한다.
        * 공개키/개인키 암호화 알고리즘이 대표적인 비대칭형 암호화 알고리즘이다.
        * 공개키는 기관이 가지고 있다.
        * 개인키는 내가 가지고 있다.
        * 개인키로 암호화한 것은 공개키로 복호화할 수 있다.
        * 공개키로 암호화한 것은 개인키로 복호화할 수 있다.
                  * 복호화에 필요한 키를 네크워크를 통해서 전송할 필요가 없다.

대칭키 : 데이터를 암호화하고 해독하는 데 동일한 키를 사용.

평문 -> 암호문 : 대칭형
대칭키 + 암호문을 암호화하기 위해 개인키를 사용함. 
은행은 개인키를 소유한 사람의 공개키로 암호를 해독함.

비밀번호 찾기를 할 때 임시 비밀번호를 발급해주는 이유는
단방향 암호화 방식으로 비밀번호를 저장하기 때문임.

내일부터는 수업 시간에 직접 해보는 것도 시작.


