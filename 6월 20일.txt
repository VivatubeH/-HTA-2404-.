-상속
  * 부모 클래스를 상속받아서 같은 종류의 자식 클래스를 여러 개 정의할 수 있다.
  * 자식 클래스의 공통 속성과 공통 기능을 포함하는 부모 클래스를 정의하고, 부모 클래스를 상속받아서
    빠르게 하위 클래스를 정의하기 위해서 상속을 사용한다.
  * 상속의 의의	
     - 클래스 형변환이 가능해진다.
     - 모든 하위 클래스를 전부 부모타입으로 다룰 수 있게 된다.
     public class Sample {
       Parent p; // p에 모든 자식 객체를 조립할 수 있다. 멤버변수의 다형성
     }
     public class Sample {
         public void test(Parent p) { <--- p에 모든 자식 객체를 인자로 전달할 수 있다. 매개변수의 다형성
       
         }
     } 

     public class Sample {
        public void test(int x) {
          Parent p = null; <---- p에는 모든 자식 객체의 주소값을 대입할 수 있음. 지역변수 다형성
          if ( x == 1 ) {
              p = new Child1();
          } else if ( x == 2 ) {
              p = new Child2();
          } else {
              p = new Child3();
          }
        }
       }

       public class Sample {
           public Parent test(int x) { <---- 반환타입이 Parent이면 모든 자식객체를 반환할 수 있다.
           // 반환 타입의 다형성
                 if ( x== 1 ) {
                        return new Child1();
                 } else if ( x == 2 ) {
                         return new Child2();
                 } else {
                         return new Child3();
                 }
              }
           }	 

- 클래스 형변환
     * 상속관계(구현관계)에 있는 객체는 부모타입의 참조변수로 자식 객체를 참조할 수 있다.
      생성된 객체를 참조하는 참조변수는 해당 객체와 같은 타입의 참조변수
                                                          혹은 해당 객체의 부모타입의 참조변수만 가능하다.
      Child c = new Child(); <-- 생성한 객체와 같은 타입의 참조변수만 가능하다.
      Parent p = new Child(); <-- 생성한 객체의 부모 타입 참조변수로 참조한다.
      GrandParent p = new Child(); <-- 생성한 객체의 조상 타입 참조변수로 참조한다.

[ 자바에서 참조한 객체와 참조변수의 타입이 다르면 무조건 부모를 찾아감 ]
* 클래스 형변환된 객체(부모타입의 참조변수로 객체를 참조하고 있다)는 참조변수가 참조하는
위치에 따라 사용가능한 속성과 기능이 달라진다.
    Child c = new Child();   
        * Child 객체의 공개된 모든 속성과 기능
        * Parent 객체의 공개된 모든 속성과 기능
        * GrandParent 객체의 공개된 모든 속성과 기능
        * Object 객체의 공개된 모든 기능
    Parent p = new Child();
       * Parent 객체의 공개된 모든 속성과 기능
       * GrandParent 객체의 공개된 모든 속성과 기능
       * Object 객체의 공개된 모든 기능
    GrandParent p = new Child();
       * GrandParent 객체의 공개된 모든 속성과 기능
       * Object 객체의 공개된 모든 기능
   * 클래스 형변환된 객체(부모타입의 참조변수로 객체를 참조하고 있다.)는
   강제형변환 연산자를 이용해서 다른 위치의 객체를 참조할 수 있다.
      Parent p = new Child();
      Child c = (Child)p;
      * 클래스 형변환된 부모타입의 참조변수로 Child 객체의 공개된 속성과 기능을 사용할 수 없으므로

   - 메소드 재정의
      * 부모로부터 상속받은 메소드를 자식 클래스에서 재정의 하는 것이다.
      * 재정의 규칙 
         접근제한자 - 재정의할 메소드의 접근제한자와 동일하거나 더 느슨한 접근제한만 허용한다.
         반환타입, 메소드명, 매개변수 - 재정의할 메소드와 완전히 동일해야 한다.
         구현내용 - 다르게 구현한다.
      * 메소드 재정의의 목적
           + 부모로부터 상속받은 메소드를 자식클래스에서 자신에게 맞게 기능을 구현할 수 있게 한다.
           + 클래스 형변환된 경우, 부모타입의 참조변수로 실제 생성된 객체를 참조하는 것이 아니라
               부모 타입 객체를 참조하고 있다.
              그렇기 때문에 실제 생성된 객체의 메소드를 실행할 수 없다.
              하지만, 자식 객체에서 재정의된 메소드는 클래스형변환으로 부모객체를 참조하고 있어도
              실행이 가능하다.
              결론, 클래스형변환으로 부모 객체를 참조하고 있어도, 실제 생성된 자식 객체의 재정의된 
              메소드를 실행할 수 있다.

    - 추상화 
      * 구현 클래스(하위 클래스)에서 반드시 구현할 기능을 상위 클래스에서 구현부가 없는 추상메소드로 정의하는 것.
      * 일반적으로 new 키워드를 사용해서 객체 생성해서 사용하는 클래스는 전부 구현 클래스다.
      * 구현 클래스는 추상 메소드를 보유할 수 없다. 만약 상위 클래스(혹은 인터페이스)로부터
      추상메소드를 물려받았다면 추상 메소드를 반드시 재정의해야 한다.
      * 추상화의 목적 
           + 하위 구현 클래스가 반드시 구현할 기능을 강제할 수 있다. 
           + 상위 클래스(혹은 인터페이스)를 구현한 구현 클래스는 사용법이 동일한 메소드를
           모두 가지게 된다. [ 구현 클래스는 서로 다르지만 비슷한 기능에 대한 사용법은 같다. ]
        + 상위 클래스(혹은 인터페이스)에서 추상화 된 메소드는 구현 클래스에서 메소드 재정의 방식으로 구현하게 된다.
              * 메소드 재정의의 장점을 전부 적용받는다.

    - 추상클래스와 인터페이스
        * 추상메소드를 사용해서 구현 클래스가 반드시 구현할 기능을 추상화할 수 있다.
        * new 키워드를 사용해서 객체 생성할 수 없다.
        * 익명 클래스를 이용해서 즉석에서 추상화된 메소드를 구현하면 객체 생성이 가능하다.
        * 추상 클래스
                    + 클래스의 모든 구성 요소와 추상 메소드를 보유할 수 있다.
                    + 구현 메소드를 포함할 수 있기 때문에, 자식 클래스의 구현 부담을 줄여줄 수 있다.
                          * 구현 클래스의 공통 기능, 공통 속성을 추상 클래스에 전부 정의하면 구현 클래스에서
                           추상화된 메소드만 구현하면 된다.
        * 인터페이스
                 + 상수, 추상 메소드, default 메소드, 정적 메소드를 보유할 수 있다.
                  * default 메소드와 정적 메소드는 Java 8부터 인터페이스에 정의할 수 있다. 
                  * 일반 개발자가 default와 정적 메소드를 인터페이스에 정의하는 경우 거의 없다.
                 + 인터페이스는 구현 클래스가 반드시 구현할 기능에 대한 명세(스펙, 표준)을 추상 메서드로 정의한다.
        [ 사용법이 동일하다 = 교체 가능하다 ]
                  + 인터페이스는 사용법이 동일한 구현 클래스를 작성 가능하게 함으로써, 
                   사용하는 클래스에서 인터페이스에 맞춰서 코딩해놓았다면 어떤 구현객체와
                   조립되더라도 코드 변경없이 사용이 가능해진다.

     명세서(인터페이스)를 정의한 목적
   - 다양한 리소스를 대상으로 수행되는 조회, 변경, 삭제, 추가 작업을 동일한 사용법으로 구현하게 한다.
   [ 코드 변경 없이 교체 가능하게 하기 위해서 ]

API(Application Programming Interface) 
- 응용 프로그램 개발에 사용되는 컴포넌트가 제공하는 기능 혹은 그 기능을 사용하는 방법
- 응용 프로그램 개발에 사용되는 컴포넌트의 사양(Specification)을 말한다.
컴포넌트(component) : 여러 개의 프로그램 함수들을 모아 하나의 특정한 기능을 
수행할 수 있도록 구성한 작은 기능적 단위

Java SE의 주요 패키지 [ 그냥 이런 게 있구나.. 정도만 ^^ ]
 - java.lang 패키지
      + 자바의 가장 기본적인 클래스, 인터페이스들이 정의된 패키지다.
      + java.lang 패키지에 정의된 것들은 import 구문없이 사용 가능하다.
      + 주요 API
             Object : 최상위 루트 클래스
             System : JVM이 실행중인 시스템과 관련된 기능을 제공하는 클래스
             String, StringBuilder, StringBuffer : 문자열 관련 기능을 제공하는 클래스 
             Math : 수학 연산과 관련된 기능을 제공하는 클래스
             Wrapper 클래스 : 기본 자료형값을 표현하는 클래스
             Thread : 멀티 스레드( 동시 작업 )을 지원하는 클래스

 - java.util 패키지
         + 자바의 자료 구조, 유틸리티 클래스들이 정의된 패키지다.
         + 애플리케이션 개발에 가장 많이 사용되는 패키지다.
         + 주요 API
              자바의 자료구조 API : Collection, List, Set, Map, ArrayList, HashSet, HashMap, LinkedList, Stack
              Data, Calendar : 날짜 관련 클래스
              유틸리티 클래스 : Arrays, Objects, Collections 

 - java.io 패키지
          + 자바의 입출력 관련 클래스들이 정의된 패키지다.
          + 다양한 리소스를 대상으로 읽고 쓰기를 지원하는 클래스들이 정의되어 있다.
          + 주요  API
                  InputStream, FileInputStream
                  OutputStream, FileOutputStream
                  Reader, FileReader
                  Writer, FileWriter
	     PrintStream

 - java.net 패키지
           + 네트워크 통신 관련 클래스들이 정의된 패키지다.
           + ip 주소를 표현하는 클래스, 컴퓨터간의 데이터 교환을 지원하는 클래스 등이 정의되어 있다.
           + 주요 API
                 URL : url 주소를 표현하는 클래스
                 InetAddress : ip 주소를 표현하는 클래스
                 Socket, ServerSocket : 클라이언트 - 서버 기반의 통신을 지원하는 클래스

- java.sql 패키지
     + 데이터베이스 엑세스 관련 클래스들이 정의된 패키지다.
     + 주요 API
           Connection : 데이터베이스와의 연결을 담당하는 클래스다.
           Statement, PreparedStatement : SQL 구문을 표현하는 클래스다.
           ResultSet : 조회 결과를 표현하는 클래스다.

- java.time 패키지
      + 날짜, 시간 관련 클래스가 정의된 패키지다.
      + java.util의 Date와 Calendar은 날짜와 시간 관련 기능이 빈약하기 때문에 java8부터 새롭게 추가된 패키지다.
      + 주요 API 
           LocalDate : 날짜를 표현하는 클래스다.
           LocalDateTime : 시간을 표현하는 클래스다.
           Instant : 특정 시점의 시간을 표현하는 클래스다.
           Period, Duration : 날짜와 시간차를 표현하는 클래스다.

- java.function 패키지
        + 람다식 관련 인터페이스가 정의된 패키지다.
        + 람다식이 도입된 java8부터 새롭게 추가된 패키지다.

Object 클래스
- 배열을 포함한 모든 객체의 최상위 부모 클래스다.
- Object에 있는 메소드들은 모든 클래스가 상속받는다.
- Object에는 객체와 관련된 필수 기능들이 구현되어 있다.

자바 API에서는 protected와 public만 볼 수 있다.
( private, default는 볼 수 없음 ) 

메서드에 - 줄 그어져있는 건 폐기 예정임을 뜻함. 

@Deprecated(since="9")
    protected void finalize() throws Throwable { } // 자바 9버전부터 폐기 예정임.

네이티브 메서드(Native method)[ native가 붙은 것 ] : C, C++와 같은 네이티브 프로그래밍 언어로 작성한 메서드  

boolean equals(Object obj) - 현재 객체와 전달받은 객체가 동일한 객체인지 여부 반환, 주소값 참조값 반환
int hashCode() -  찾을 때 해시코드값을 통해 빠르게 찾을 수 있다.

boolean equals(Object other)
- 이 객체와 다른 객체가 동일한 객체인지 확인해서 같은 객체이면 true를 반환한다.

int hashCode()
- 이 객체의 해시코드값을 정수값으로 반환한다. 같은 객체라면 해시코드값이 동일하다.

String toString()
- 이 객체에 대한 간단 정보를 문자열로 반환한다.
- 패키지명.클래스명 + @ + 16진수해시코드값
 [ 주소값은 절대로 알 수 없음 ]

재정의 할 때 ctrl + space 누르면 어차피 재정의 가능한 것만 나옴.

toString 타이핑하지말고 이클립스에서 그냥 오버라이딩 해주는 거 갖다 쓰기.

* Object의 toString() 메소드 재정의하기 [ 값을 표현하는 객체에서 ]
- Object의 toString() 메소드는 객체에 대한 간단한 정보를 문자열로 제공하는데, 우리가 정의한 클래스에서는 별로 유용하지 않다.
만약, 클래스가 값을 표현하는 객체를 생성할 목적으로 정의된 것이라면 객체의 멤버변수에 어떤 값이 대입되어 있는지가 더 중요하다.
toString() 메소드를 재정의해서 멤버변수명과 해당 변수에 저장된 값을 문자열로 만들어 반환하도록 한다.
주의 - 비밀번호 같은 건 toString 재정의할 때 제외하기. [ 보안 관련 사항, 중요 정보 등... ]

비교 방식 2가지
1. 동일성 비교 : 같은 객체인지 비교 [ 객체에 대한 동일성(주소) 비교는 사실상 의미 없음 ]
2. 동등성 비교 : 같은 값을 갖고 있는지 비교

Object의 equals()는 항상 같은 객체일 때만 true가 됨.

★ equals()를 오버라이딩 하려면 항상 hashCode()도 같이 오버라이딩 해줘야 함. ★

hashCode()랑 equals() 메소드 오버라이딩 할 때 그냥 자동완성 시키자.

== 연산자는 두 객체의 동일성( 주소값 )을 비교한다.
== 연산자는 참조변수가 참조하는 두 객체가 완전히 동일한 객체일 때만 true를 반환한다.

equals() 메소드 - 기본적으로는 동일성 비교지만, 재정의를 통해 동등성 비교를 하게 만들 수 있음.

 자바의 동일성과 동등성

 + 객체의 동일성
    두 객체가 메모리에서 같은 주소 위치를 차지하고 있는지를 비교하는 것이다.
    즉, 같은 객체인지를 비교하는 것이다.
    객체의 동일성은 == 연산자로 확인할 수 있다.

 + 객체의 동등성
    두 객체의 상태가 값이 같은지를 비교하는 것이다.
    객체의 동등성은 equals()와 hashCode() 메소드를 재정의해서 구현할 수 있다.
    * 동등성 비교에 hashCode() 메소드를 재정의하는 이유
        - equals() 메소드가 true를 반환하는 두 객체는 같은 객체로 간주되기 때문에 해시코드 값도 같은 값을 가져야 하기 때문
        - 해시코드 값은 HashSet, HashMap과 같은 해시기반 콜렉션에서 객체를 구별하는데 기본으로 사용되는 값이기 때문에
        재정의해야 한다. [ equals() 보다 hashCode()를 먼저 사용하므로 ]

Reflection API - 객체를 반사시켜서 객체를 통해 클래스의 정보를 분석하여 런타임에 클래스의 동작을 검사하거나 조작하는 기법.
[ 쓸 일은 없음... 프레임워크 개발할 때 사용 ] 

throws - 예외를 생성해서 던짐. [ 오류 정보를 담고 있는 객체를 만들어서 던짐 ] 

[ 예외가 발생할 경우에 대비한 예외 처리 구문을 필수로 해놔야 함. ]

예외 처리의 2가지 방법 - 잡거나 or 다시 던지거나

Object의 clone() 메소드
- Object에 정의된 메소드
- 이 객체의 복제본 객체를 생성해서 반환한다.
- 반환 타입이 Object이다. [ 어떤 걸 복제할 지 모르니 반환 타입을 Object로 한다. ]

Cloneable이라는 마크업 인터페이스를 붙인 클래스만 복제가 가능하다.

clone()은 얕은 복제만 가능하다.

