네트워크 : 여러 대의 컴퓨터가 통신회선으로 연결되어 있는 시스템.

Client <------------------------------------------------- Server
             클라이언트가 요청을 보내면 서버가 응답한다.

Server : 서비스를 제공하는 프로그램
Client : 서비스를 제공받는 프로그램 

하나의 서버에는 여러 개의 클라이언트가 연결될 수 있다.

클라이언트와 클라이언트 간에는 직접적으로 연결되지 않음. [ 일반적으로 ]

Client <----------> Client
	연결 x

항상 서버가 중간에 매개역할을 해줘야 함. 

host : 네트워크에 연결되어 있고, 다른 호스트와 통신 가능한 컴퓨터
[ ip 주소로 식별 가능함 ] 

ip address : 네트워크에서 호스트를 식별하기 위해 부여되는 고유한 주소
[ IPv4, IPv6 주소 체계가 있음 ]

port : 실행 중인 서버프로그램의 논리적인 연결 지점.
모든 프로그램은 특정한 포트 번호를 가지고 실행된다. [ 0 ~ 65535까지 ]
포트번호를 통해 서비스를 제공하는 서버프로그램을 선택할 수 있다.
네트워크 장치(호스트)에서 특정 프로세스나 서비스와의 통신을 식별하고 구분하기 위해 사용됨.
[ 서버 프로그램마다 하나의 포트 번호가 고유하게 할당되어야 한다. ]

http://192.168.0.29:80/index.html
[ 프로토콜, ipv4 주소, 포트번호 : 80 ] 

ftp://192.168.0.29:21/a.txt
[ 프로토콜, ipv4 주소,  포트번호: 21 ]

protocol: 네트워크에 연결된 host 간의 데이터 교환을 위해 미리 약속된 통신규약
물리적 또는 논리적 통신을 처리하기 위한 통신 세트
tcp, ip, http, https, ftp, telnet, smtp, ...

IPv4 : 32비트로 구성되며 총 2^32개만큼의 주소를 가진다.
공인 ip주소 - 다른 컴퓨터와 통신할 때 사용하는 ip 주소
사설 ip주소 - 외부 인터넷으로 접속은 불가능함. 가상 ip, 사설망 내에서만 사용
[ 같은 네트워크에서는 상관없지만, 다른 네트워크간에는 중복될 가능성이 있다. ]
[ 고로 사설 ip는 외부에서 골라서 접속하는 건 안 된다. ]

host는 개별 pc에 부여된다.

-----------------------------------------------------------------------------------------------

IP 클래스

네트워크 - 서비스 제공 업체가 제공해줌.
호스트 - 할당할 수 있음. [ 개별 pc에 부여됨 ]

클래스A
: xxx.???.???.??? - 1.???.???.??? ~ 127.???.???.???
 [00000001 ~ 01111111] 맨 앞 1바이트는 네트워크, 뒤의 3바이트가 호스트이다.
  주소 : 1.0.0.0 ~ 127.255.255.255
  네트워크 당 호스트 갯수 : 2^24 - 2 [ 실질적으로는 1.0.0.1 ~ 1.255.255.254까지만 가능함. ]
 
  네트워크 ip - 같은 네트워크인지 식별할 때 사용하는 IP, 컴퓨터에 할당할 수 없다.
  1.0.0.0

   브로드캐스트 ip - 네트워크 상의 모든 컴퓨터에 메시지를 보낼 때 사용되는 IP, 컴퓨터에 할당할 수 없다.
  1.255.255.255
	
  [00000001][xxxxxxxx][xxxxxxxx][xxxxxxxx]
  [01111111][xxxxxxxx][xxxxxxxx][xxxxxxxx]

  처음 8비트가 네트워크 ip, 나머지 24비트가 호스트 ip이다.
  ★ 처음 8비트는 고정된다. ★
  네트워크 당 1670만대 이상의 호스트를 연결할 수 있다.

  2.x.x.x ip 사용해

클래스B
: xxx.xxx.???.??? - 128.xxx.???.??? ~ 191.xxx.???.???
  [ 10000000 ~ 10111111 ] 맨 앞 2바이트는 네트워크, 뒤의 2바이트가 호스트이다.
   주소 : 128.0.0.0~191.255.255.255
   호스트 개수 : 2^16 - 2 = 65534개
  
   [10000000][		][xxxxxxxx][xxxxxxxx]
   [10111111][		][xxxxxxxx][xxxxxxxx]

   처음 16비트가 Network ID, 나머지 16비트가 Host ID.
   처음 16비트는 고정된다.
   Host ip 대역이 총 16비트다. 네트워크 당 6만5천대 이상의 호스트를 연결할 수 있다.	
  
  129.23.x.x ip 사용해
 
클래스C
: xxx.xxx.xxx.??? - 192.xxx.xxx.??? ~ 223.xxx.xxx.???
 [ 11000000 ~ 11111111 ] 맨 앞 3바이트는 네트워크, 뒤의 1바이트가 호스트이다.
	
 주소 : 192.0.0.0 ~ 223.255.255.255
 호스트 갯수 : 2^8 - 2 = 254개

 [11000000][		][		][xxxxxxxx]
 [11011111][		][		][xxxxxxxx]

 처음 24비트가 Network ID, 나머지 8비트가 HostID
 처음 24비트는 고정된다. 
 HostIP 대역이 총 8비트고, 네트워크 당 250대 이상의 호스트를 연결할 수 있다.

  195.12.2.x ip 사용해 

네트워크 IP와 브로트캐스트 IP

네트워크 IP : 해당 IP 대역의 첫 번째 호스트 주소
	      해당 네트워크 자체를 나타내는 IP 주소다.
	      호스트에 할당할 수 없다.

브로드캐스트 IP : 해당 IP 대역의 마지막번째 호스트 주소
 	            해당 네트워크에 연결된 모든 호스트에 메세지를 보낼 때 사용되는 IP주소다.
		호스트에 할당할 수 없다.

예시) 할당받은 IP 주소
         192.168.2.x

        네트워크 IP 192.168.2.0
  
        브로드캐스트 IP 192.168.2.255

        할당가능한 IP 주소 192.168.2.1 ~ 192.168.2.254
--------------------------------------------------------------------------------------------------

서브넷 : ip 클래스를 더 작은 단위의 네트워크로 나누는 것.
            네트워크를 분할하는 것을 서브넷팅(Subnetting)이라고 하고,
            서브네팅은 서브넷 마스크(Subnet Mask)를 사용해서 네트워크를 구분한다.

서브넷 마스크: 서브넷 마스크는 IP 주소를 네트워크 ID와 Host ID로 구분하기 위한 목적으로 만든 것이다.
	         서브넷 마스크는 1과 0으로만 표현되고 중간에 0이 들어갈 수 없다.

A 클래스의 default 서브넷 마스크 : 255.0.0.0
B 클래스의 default 서브넷 마스크 : 255.255.0.0
C 클래스의 default 서브넷 마스크 : 255.255.255.0

IP 주소와 subnet 마스크를 and 연산하면 네트워크 IP를 계산할 수 있다.

예 )
[ 1.1.1.4와 1.1.1.10은 같은 네트워크인가? ]
- ip 주소의 클래스가 A 클래스다.
- A클래스의 서브넷 마스크 기본값은 255.0.0.0이다.
- ip주소와 서브넷 마스크를 &연산하자.

1.1.1.4     = 00000001 00000001 00000001 00000100
255.0.0.0 =  11111111 00000000 00000000 00000000
-------------------------------------------------
      &          00000001 00000000 00000000 00000000 -> 1.0.0.0 [ 네트워크 IP ]

1.1.1.10도 마찬가지로 1.0.0.0이라는 네트워크 IP를 갖는다. 

- 1.1.1.4와 1.1.1.10은 같은 네트워크 ip를 가지고 있으므로
  같은 네트워크 안에 위치하는 호스트다.

네트워크 분할하기
	
	예) 192.168.10.x 네트워크를 2개로 분할하기
	
	-192.168.10.x는 C 클래스여서 default 서브넷 마스크가 255.255.255.0이다.
	- C 클래스를 2개로 분할하려면 서브넷 마스크를 255.255.255.128이다.

             192.168.10.10과 192.168.10.50은 같은 네트워크인가?
	192.168.10.10은 뒤의 8비트가 00001010
              192.168.10.50은 뒤의 8비트가 00110010이다.

             서브넷 마스크를 255.255.255.128로 하니까
	뒤의 8비트만 서브넷 마스크를 적용해보면
	00001010과 10000000을 곱연산하면 00000000
             00110010과 10000000을 곱연산하면 00000000
             즉 둘 다, 네트워크 ip가 192.168.10.0이 된다.

             반면 192.168.10.132는 255.255.255.128과 곱연산하면 192.168.10.128이라는 네트워크 ip를 갖는다.
	
	192.168.10.10과 192.168.10.132는 서로 통신이 불가능하다.

	예) 192.168.10.x 네트워크를 4개로 분할하기
	
	-192.168.10.x는 C 클래스여서 기본 서브넷 마스크는 255.255.255.0이다.
	- C 클래스를 4개로 분할하려면 서브넷 마스크 255.255.255.192이다.

네트워크 분할과 ip 주소
	- C 클래스 주소를 분할없이 사용하기
		ip : 192.168.10.x
		서브넷 마스크 : 255.255.255.0
		네트워크 ip : 192.168.10.0
		브로트캐스트 ip : 192.168.10.255
 		총 호스트 갯수 : 254개

             - C 클래스 주소를 2개로 분할해서 사용하기
		ip: 192.168.10.x

		서브넷 마스크 : 255.255.255.128
		
		첫 번째 네트워크
		네트워크 ip : 192.168.10.0
		브로드캐스트 ip : 192.168.10.127
		총 호스트 갯수 : 126개
		
		두 번째 네트워크
		네트워크 ip : 192.168.10.128
		브로드캐스트 ip : 192.168.10.255
		총 호스트 갯수 : 126개

	- C 클래스 주소를 4개로 분할해서 사용하기
	 	ip : 192.168.10.x
		
		서브넷 마스크 : 255.255.255.192
		
		첫 번째 네트워크
		네트워크 ip : 192.168.10.0
		브로드캐스트 ip : 192.168.10.63
		총 호스트 갯수 : 62개
		
		두 번째 네트워크
		네트워크 ip : 192.168.10.64
		브로드캐스트 ip : 192.168.10.127
		총 호스트 갯수 : 62개
		
		세 번째 네트워크
		네트워크 ip : 192.168.10.128
		브로드캐스트 ip : 192.168.10.191
		총 호스트 갯수 : 62개
		
		네 번째 네트워크
		네트워크 ip : 192.168.10.192
		브로드캐스트 ip : 192.168.10.255
		총 호스트 갯수 : 62개

-------------------------------------------------------------------------------------------------------

루프백 ip(loopback ip) : 자기 자신을 나타내는 ip 주소
- 192.168.0.4 

IPv6 : IP 고갈 문제를 해결하기 위해 등장함.
0000:0000:0000:0000:0000:0000:0000:0000 ~ ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
[ 16비트 짜리가 8개 있음 ]

게이트웨이 : 서로 다른 네트워크로 이동하기 위한 통로
( 내부 네트워크가 아닌 외부 네트워크와 통신하는 경우 반드시 거쳐야 함. )

DNS 서버 : 도메인 네임에 해당하는 IP 주소를 알려줌.

cmd 창에서 nslookup 하고 웹사이트 주소 치면 아이피 주소를 알려줌.

TCP/IP -

TCP : 컴퓨터가 다른 컴퓨터와 데이터 통신을 하기 위한 표준을 정의하는 프로토콜
[ 데이터를 순서대로 전송 및 오류 검출 ] [ 데이터 전송을 위한 표준 ]

IP : 호스트를 식별하기 위한 ip 주소체계를 정의하는 프로토콜
[ 컴퓨터 식별을 위한 표준 ]

OSI 7계층과 TCP/IP 4계층

계층은 네트워크 통신이 일어나는 과정을 단계별로 나눈 것이다.

OSI 7계층 
[ 응용 계층 ]
[ 표현 계층 ]
[ 세션 계층 ]
[ 전송 계층 ]
[ 네트워크 계층 ]
[ 데이터링크 계층 ]
[ 물리 계층 ]

TCP/IP 4계층
[ 애플리케이션 계층 ] HTTP, FTP, SMTP, telnet 
[ 전송 계층 ] 	TCP, UDP
[ 인터넷 계층 ]	IP
[ 네트워크 액세스 계층 ] Ethernet

보내는 쪽에서는 

HTTP 메시지
        ↓
TCP... TCP... TCP [ 각각이 TCP 헤더를 가지고 있음 ( 순서 , 오류검출용 )
        ↓	
IP.... IP... IP... [ 각각이 IP 헤더 / TCP 헤더를 가지고 있음 ( 목적지 ip 주소, 소스 ip 주소 )
        ↓
Ethernet... [ 각각이 Ehternet 헤더(mac 주소)/ IP 헤더 / TCP 헤더를 가지고 있음 ]

최종적으로 [Ethernet 헤더][ IP 헤더 ][ TCP 헤더]가 앞에 붙음.

사용자 PC에서는

애플리케이션
     ↓
   전송
     ↓
  인터넷
     ↓
 데이터 엑세스

받는 측에서는 거꾸로 
데이터 엑세스 → 인터넷 계층 → 전송 계층 → 애플리케이션 계층 
으로 정보를 최종적으로 이용할 수 있는 정보를 뽑아냄.

-----------------------------------------------------------------------------------------------------

자바에서의 네트워크

클라이언트 <-------> 서버

서버에는 반드시 서버소켓이 있어야 한다.

ServerSocket: 클라이언트의 연결요청을 대기한다. ( 포트를 지정해줘야 함 )

Socket : 서버와 통신을 담당함. 서버의 IP 주소, 포트번호를 지정해야 함.

Client --------------------------------------------------->  Server
	 |					     |
 Socket    |	 	연결 요청.		     | ServerSocket
              |--------------------------------------------->|  Socket 
  write      |>________________스트림 1______________________>| read	 					     |
  read	 |<________________스트림2_______________________<| wrtie                                                       
              |                                                                      |
2개의 스트림이 생성되는데, 각각으로 향하는 스트림이 생성됨.
[ 각각에서 Write를 하면 반대쪽에서 Read를 할 수 있음 ]

즉 소켓을 통해서 클라이언트와 서버 간의 통신이 일어남.

자바에서 네트워크는 단순한 I/O작업임. [ 단, 파일이 아닌 Socket이 리소스가 됨 ]

서버에서는 동시에 여러 개의 소켓을 가질 수 있다.

getOutputStream(), getInputStream()을 통해서 획득 가능.

out = socket.getOutputStream() <-------------> socket.getInputStream()
in = socket.getInputStream() <------------> socket.getOutputStream()

FileServer와 FileClient간 메세지 전송 규칙

1. 파일 다운로드 요청		파일 다운로드 응답
	DOWN:파일명		FILE:파일명+사이즈+파일데이터

	out.writeUTF("DOWN:a.txt") 	String text = in.readUTF();
				text <--- "DOWN:a.txt"
	
2. 파일 삭제 요청			파일 삭제 응답	
	DEL:파일명		DEL:파일명 + true 혹은 false

3. 파일 정보 요청			파일정보 응답
	INFO:파일명		INFO:파일명:파일사이즈

	out.writeUTF("INFO:a.txt")	String text = in.readUTF();
				text <--- "INFO:a.txt"

				// 파일 정보 조회, 응답 제공
				out.writeUTF("INFO:a.txt");
				out.writeLong(200000);

DataOutputStream 
	writeInt(정수)
	writeLong(정수)
	writeDouble(실수)
	writeBoolean(논리값)
	writeUTF(문자열)

DataInputSteam
	int readInt()
	long readLong()
	double readDouble()
	boolean readBoolean()
	String readUTF()

FileClient						FileServer	
	요청 보내기				요청 메세지 수신하기
	out.wirteUTF("DOWN:a.pdf");			in.readUTF() -> "DOWN:a.pdf"

						요청 처리하기(응답 메세지 보내기)
						"FILE:a.pdf" + 3000000 + 01010101010111101111

자바의 네트워크

- 소켓을 대상으로 읽기, 쓰기를 수행하는 것.

사용자 컴퓨터의 클라이언트 프로그램 = 웹 브라우저

서버 컴퓨터의 서버 프로그램 = 웹 서버(Tomcat, jBoss 등...)
-------------------------------------------------------------------------------------------------------

