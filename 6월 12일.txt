이클립스 window-preferences-java-editor-content assist에서 Fill method arguments and show guessed arguments
를 Insert parameter names로 체크하기 [ 원래 매개변수의 이름을 그대로 넣는 게 이상적임. ]

- 매개변수의 개수가 많을 때는 추천되는 매개변수명으로 입력되면 이상한 값이 들어가는 경우가 많음.
주의하자.

Public class Simple{
	int no;
	String name;  // 얘네 둘은 멤버변수, 인스턴스변수, 프로퍼티

	static int x;
	static String y; // 얘네 둘은 정적변수, 클래스변수

	public Sample() {} 

	public void test(){
	System.out.println("번호:" + no); // 얘는 멤버메소드, 인스턴스메서드

	public static test2() {
	System.out.println("x의 값:" + x); // 얘는 정적메서드, 클래스메서드
}

static이 안 붙은 애들은 new를 통해 객체를 만든 뒤에 사용이 가능하다.
하지만 static이 붙은 애들은 설계도를 메모리에 로드하는 순간 객체 생성 없이도 사용 가능함.

static은 객체의 멤버가 아니라고 생각하는 게 편하다.

클래스 이름으로 접근하는 변수라서, 클래스 변수라고 부르는 것임.

staitc이 붙으면 소스코드에 클래스 이름이 등장만 하면 무조건 클래스가 메모리에 로딩된다.

설계도가 메모리에 로딩되는 2가지 경우
1. new 연산자로 객체를 생성할 때 Sample s = new Sample();
2. 클래스 변수를 사용할 때 Sample.y = 100;

static 멤버는 클래스이름.멤버명으로 접근이 가능함.

정적 변수는 클래스에 고정되고, 객체 생성에 참여하지 않음.

정적 변수로 가지는 기준 - 객체마다 똑같은 값을 가질 때 
용도
1. 모든 객체가 같은 값을 가지는 것. 
2. 애플리케이션이 실행되는 동안 한 번 설정된 값이 변하지 않고 계속 유지되어야 하는 경우 ( 상수 )

정적 변수와 정적 메서드의 활용

- 정적 변수
 + 상수를 정의할 때 정적변수를 사용한다. ( 그 외는 잘 안씀 )
   * 상수(Constant)는 한번 설정한 값을 바꿀 수 없는 저장소이다.
   * final 키워드를 사용하면 상수를 정의할 수 있다.

   static final double DEPOSITE_RATE = 0.02;

- 정적 메소드
  + 객체의 상태와 상호작용이 필요없는 기능의 구현에 사용한다.
  + 정적메소드는 주로 유틸클래스에서 단순한 기능의 구현에 사용한다.
	*유틸클래스는 애플리케이션의 여러 곳에서 광범위하게 자주 사용되는 기능들이 구현된 클래스
        * 유티클래스에서 제공하는 기능은 객체와의 상호작용없이 매개변수로 전달받은 값을
	계산해서 결과값을 반환하는 기능이 대부분이다
	* 따라서 유틸클래스에 정의된 기능들은 대부분 정적메서드로 구현된다.   

* 대표적인 유틸클래스
	public class System { ... } // 지바 애플리케이션이 실행중인 시스템에 대한 정보 제공
		* 사용예
		    정적변수 
			System.in - 시스템의 표준 입력장치를 표현하는 객체가 대입되어 있다
			System.out - 시스템의 표준 출력장치를 표현하는 객체가 대입되어 있다
			System.err - 시스템의 표준 에러출력장치를 표현하는 객체가 대입되어 있다
		     정적메소드
			System.currentTimeMillis() - 시스템의 현재 유닉스타임값을 반환
			System.getenv() - 시스템의 환경변수값 반환
			System.getProperties() - 시스템의 설정정보를 반환
			System.exit() - 애플리케이션을 종료한다
			System.arraycopy() - 배열복사기능을 제공한다.

	public class Math { ... } // 수학 계산과 관련된 기능 제공
	public class Arrays { ... }
	* 사용예 Math.random(); // 난수값 반환
		 Math.cos(30); // 코사인값 반환	
		 Math.abs(-10); // 절댓값 반환
		 Math.min(10, 100); // 더 작은 값을 반환
		 Math.max(10, 100); // 더 큰 값 반환
		 Arrays.toString(배열) // 배열에 저장된 값을 출력하기 좋은 문자열로 제공
		 Arrays.sort(배열) // 배열에 저장된값을 오름차순으로 정렬시킨다.
		 Arrays.binarySearch(배열, 값); // 배열에 저장된 값을 이진검색으로 검색한다.

클래스들 사이의 관계 

- has a 관계 [ 포함관계 ] : 
 
특정 클래스가 다른 클래스에 구현된 기능을 사용해야 할 때 

 A has a B = A에는 B가 조립되어 있다. 
 A has a C = A에는 C가 조립되어 있다. 
 A has a D = A에는 D가 조립되어 있다.

[ A클래스 : 사용하는 클래스 ,  B/C/D클래스 : 사용되는 클래스 ] 
[ A클래스는 B클래스/C클래스/D클래스에 구현된 기능을 사용하기 때문에 B클래스/C클래스/D클래스를 포함(조립)하고 있어야 한다. ]

 * 클래스가 다른 클래스를 포함하고 있는 관계

 * A클래스는 B클래스, C클래스, D클래스를 포함하고 있다.
 * A클래스에는 B클래스, C클래스, D클래스가 조립되어 있다.
 * A클래스는 B클래스, C클래스, D클래스에 의존하고 있다.

- is a 관계 [ 상속관계 ] :



 A1 is a A = A1도 A다. 
 A2 is a A = A2도 A다. 
 A3 is a A = A3도 A다. 

[ A클래스: 상위클래스, 부모클래스.     A1클래스/A2클래스/A3클래스 : 하위클래스, 자식클래스 ]
[ 부모클래스에는 자식클래스의 공통속성과 공통기능이 정의되어 있다. ]
[ 부모 클래스가 정의되어 있다면, 부모클래스를 이용해서 자식 클래스를 빠르게 정의할 수 있다. ]
[ 부모클래스를 상속받으면 공통 속성과 기능을 물려받기 때문에 정의할 필요가 없다. ]
[ ★ 여러 자식 클래스를 하나의 부모타입클래스로 다룰 수 있다. ★ ]

 * A1클래스, A2클래스, A3클래스는 모두 A클래스 종류다.
 * A1클래스, A2클래스, A3클래스는 A클래스의 하위클래스다.
 * A클래스는 A1클래스, A2클래스, A3클래스의 상위클래스다.
 
예) 갤럭시, 아이폰, 샤오미는 스마트폰의 하위클래스이고, 스마트폰은 앞의 3 기종의 상위클래스이다.

is-a 관계라면 보통은 공통속성이나 공통 기능을 가지고 있다.
[ 통화 기능, 문자 기능, 알람 기능 등등등... ]

프로그램에서 일반적인 관계는 has-a 관계이다. 
[ 객체지향은 조립해서 쓰는 게 사실 메인이므로.... ]

아이폰, 갤럭시, 샤오미는 모두 스마트폰의 자식 클래스다.
아이폰/갤럭시/샤오미와 스마트폰은 is a 관계다.
모든 아이폰/갤럭시/샤오미는 스마트폰 종류(타입)다.

아이폰 a = new 아이폰();
갤럭시 b = new 갤럭시();
샤오미 c = new 샤오미();

대신
스마트폰 a = new 아이폰();
스마트폰 b = new 갤럭시();
스마트폰 c = new 샤오미();

이렇게 담는 것도 가능하다.

설계 단계에서 부모를 먼저 설계하고 자식을 설계할 수도 있고,
자식을 설계하는 과정에서 부모가 결정될 수도 있다.

상속 : 기존 클래스를 재사용해서 새로운 클래스를 작성하는 것.
- 하위 클래스는 상위 클래스의 필드와 메소드를 상속받는다.
- 상위 클래스를 확장시켜서 하위 클래스를 만드는 것.


자바에서 객체를 생성하는 순간, 자신의 조상이 먼저 만들어짐.
★ 부모의 객체를 자손에서 공유하는 게 아니라, 매번 새로 만들어짐. ★
- 자식 객체를 생성할 때마다 부모 객체가 같이 생성된다.
( 자신에게서 못 찾으면 부모에게 찾고, 그래도 못 찾으면 점점 거슬러 올라가서 찾음. )
★ 자식객체를 참조하는 참조변수로 부모객체의 공개된 속성과 기능에 접근할 수 있다.

자식에게 상속되지 않는 것.
- 생성자 메소드 ( 클래스 이름이니깐 )
- private 접근 제한자가 걸린 것. ( 생성은 되지만 자식에서 접근할 수 없음. 보이지 않음 )

자바에서 클래스의 상속은 다중 상속을 허용하지 않는다. ( 단일 상속만을 지원함 )
[ 반면 인터페이스는 여러 부모를 상속받을 수 있다. ]

부모의 멤버변수에 값을 넣고 싶은데, 부모의 멤버변수가 private으로 감춰져 있다고
그 멤버변수가 없는 게 아니라 보이지 않는 것 뿐임. 
직접적으로 넣을 순 없지만 getter나 setter 메소드를 통해서 값을 넣을 수 있음.

자식객체를 참조하는 참조변수로 자손 분만 아니라 조상 객체의 모든 공개된 속성과 기능을
사용할 수 있다. 
( 단, private 접근제한자로 숨겨진 속성과 기능은 사용할 수 없다. )

super() - super 생성자, super 생성자는 부모의 생성자를 가리킴.
[ 부모의 생성자를 호출하는 메서드임 ]

super()는 생성자의 수행문에서 항상 첫 줄에 사용해야 함.
[ 항상 자바에서는 자식보다 부모를 먼저 초기화해야함. ] 

생성자에서 super를 추가하지 않으면 무조건 super() [ 부모의 기본 생성자 호출 ]이 자동으로 추가됨.
그래서 부모 클래스를 정의할 때는 기본 생성자를 꼭 써줘야 함.

Setter를 제공하지 않는 경우에는 super를 사용해야 함.

