List<E> 인터페이스
* 순서가 보장되는 자료구조다.
* 중복 저장이 허용된다. ( 중복 여부를 체크하지 않기 때문에 발생하는 부수적인 효과 )
* 저장/삭제를 할 때마다 동적으로 크기가 조절된다.
* 중간에 추가/삭제를 할 때마다 빈 공간이 생기지 않도록 데이터를 적절히 이동시킨다.
* 배열처럼 index를 사용해서 저장된 객체에 접근할 수 있다

- 주요 API
	boolean add(E e)
	지정된 인덱스 위치에 객체를 추가한다.
	해당 위치에 저장되어 있는 객체를 뒤쪽으로 이동한다.

	boolean addAll(Collection c)
	지정된 인덱스위치에 전달받은 콜렉션에 저장된 객체를 저장한다.
	콜렉션에 저장된 객체의 갯수만큼 해당 위치에 저장되어 있는 객체를 뒤쪽으로 이동한다.

	E remove(int index)
 	지정된 인덱스 위치에 저장된 객체를 삭제하고 반환한다.
	삭제된 위치에는 뒤에 저장되어 있는 객체로 채워진다.

	E set(int index, E e)
	지정된 인덱스 위치에 새 객체로 교체한다.
	
	E get(int index)
	지정된 인덱스 위치에 저장된 객체를 조회한다

- 주요 구현 클래스
	ArrayList<E>
	+ 가변 길이 자료구조 구현 클래스
	+ 내부적으로 배열을 이용해서 객체를 저장한다.
	+ 저장되는 객체의 갯수에 맞게 자동으로 배열의 크기를 조절한다
	+ 순서대로 추가(맨 끝에 추가), 삭제( 맨 끝에 저장된 것부터 삭제) 하는 경우 속도가 매우 빠르다.
              ( 리스트 중간에 추가/ 삭제가 일어나는 경우 매우 느리다. )
	+ Thread-unsafe 하다.

	LinkedList<E>
	+ 리스트에 중간에 추가/삭제가 빈번한 경우 매우 빠른 성능을 보장한다.
	+ 임의의 위치에 저장된 객체를 조회하는 성능은 느리다.
	
	Vector<E>
	+ ArrayList와 구현 내용이 거의 비슷하다.
 	+ Thread-safe 하다.
	+ ArrayList에 비해 속도가 느리다.

	Stack<E>
	+ 후입선출(LIFE:Last-In First-Out) 자료구조다.
	+ 업무로직 구현에 사용하는 경우는 드물다.
	+ JVM에서 메소드에서 정의되는 변수를 스택으로 관리한다.
 	+ 주요 메소드	
		E push(E e)
		스택에 객체를 저장한다.
		저장된 객체는 스택에 맨 위에 위치한다.

		E pop()
		스택에서 맨 위에 저장된 객체를 삭제하고, 그 객체를 반환한다.
		
		E peek()
		스택에서 맨 위에 저장된 객체를 삭제하지 않고, 그 객체를 반환한다.

	* 일반적으로 업무 로직 구현에 사용되는 객체는 ArrayList<E>다.

한 건을 조회하는 경우
public <T> T find(...)
public <T> T selectOne(...)

여러 건을 조회하는 경우
public <T> List<T> findAll(...) // 구현 내용이 바뀌어도 반환은 List의 한 종류니깐 괜찮음.
public <T> List<T> selectList(...)

★ List<T>는 특정 타입의 객체들을 담고 있는 리스트를 반환하는 제네릭 메서드를 나타냅니다. 
즉, 메서드는 여러 개의 특정 타입 객체들을 담고 있는 리스트를 반환합니다.

ArrayList<String> names = new ArrayList<String>();
// 이렇게 써도 되지만
List<String> names = new ArrayList<String>();
// 앞은 보통 interface 타입으로 쓴다.

부가적인 메소드들도 있지만, 자료 구조의 핵심 기능은 대부분 공통으로 구현되어 있어서
앞을 그냥 interface 타입으로 쓰는 게 낫다. 

호출하는 환경에서는 무슨 리스트를 구현했는지, 어떤 작업을 했는지는 몰라야 함.
반환하는 쪽에서는 interface 타입을 알려주는 쪽으로 코딩해야 한다. ( 유지 보수 + 내부 정보 보호 등.. )

set 계열은 인덱스가 없어서 일반 for문을 사용할 수 없다.
list 계열은 인덱스가 있어서 일반 for문도 사용할 수 있다.

int size = names.size();
for(int i = 0; i < size; i++) {
	String value = names.get(i);
	System.out.println(value);			
}

이렇게 작성하는 게 맞음. 
for (int i = 0; i < names.size(); i++) {} 이렇게 작성하면
size() 메소드를 계속 호출해야 한다... 이런 것도 생각해서 코드를 작성하자.

배열은 length라는 멤버변수를 직접 접근하기 때문에 배열이름.length로 사용할 수 있지만
ArrayList는  length 자체에 접근이 불가능해서 안된다.

대부분의 경우는 그냥 enhanced for문을 쓰자......

// 리스트의 객체를 오름차순으로 정렬하기
names2.sort(Comparator.naturalOrder());
System.out.println(names2);
		
// 리스트의 객체를 내림차순으로 정렬하기
names2.sort(Comparator.reverseOrder());
System.out.println(names2);

- 리스트 계열은 sort 메소드를 사용할 수 있다. ( Set 계열은 사용 불가 ) 

객체 복제하기
+ 모든 객체의 최상위 부모인 Object에 clone() 메소드가 있다.
+ 모든 객체는 Object의 clone() 메소드를 호출해서 객체를 복제하는 기능을 작성할 수 있다.
+ 내부적으로 super.clone()을 호출해야 한다.

복제 가능한 객체
1. Cloneable 인터페이스를 구현한다.
2. 객체를 복제하는 기능을 자체적으로 구현한다.
[ Object의 clone() 메소드를 호출해서 객체를 복제하는 수행문 ]

Object 메서드는 얕은 복제만 가능해서, 복제 방식을 자유롭게 정할 수 있도록 protected로
오버라이딩하게 만듬.

clone()을 사용하는 이유 - 작업을 수행하기 전에 원본을 유지시키고 싶을 때. 

 * List<E> 객체를 만드는 3가지 방법 
		 
* new ArrayList<>()
* 객체 추가, 삭제, 변경이 모두 가능하다.
		 
* asList(E... e)
* 객체 추가, 삭제가 불가능하다.
* 단, 변경은 가능하다.
		  
* List.of(E e, E e, E e)
* 객체 추가, 삭제, 변경이 모두 불가능하다.

사용자 관리 프로그램 구현하기

1. 요구사항 분석

  + 사용자 등록/수정/삭제/조회 기능 제공
  + 사용자 등록
      아이디, 이름, 이메일, 전화번호를 입력받아서 등록한다.
  + 사용자 수정
      아이디로 사용자를 조회하고, 해당 사용자의 이메일, 전화번호를 수정한다.
  + 사용자 삭제
      아이디로 해당 사용자 정보를 삭제한다.
  + 사용자 전체 조회
      모든 사용자 정보를 조회해서 출력한다.
   + 사용자 상세 조회
      아이디를 입력받아서 해당 사용자의 정보를 조회하고 출력한다.

2. 구현하기
  
+ 프로그램 대상이 되는 사용자 정보를 표현하는 클래스를 정의하기. 

     User : [ 필드 , 기본 생성자, getter, setter 메서드 ]

3. 애플리케이션 구성하는 주요 컴포넌트 클래스를 정의하기
    
 + 사용자와 상호작용하는 클래스 UserApp
 + 업무로직을 처리를 담당하는 클래스 UserService
 + 데이터의 영속화를 담당하는 클래스 UserRepository

4. 애플리케이션을 구성하는 주요 컴포넌트를 조립하기

 + 사용자와 상호작용하는 클래스 UserApp에 Keyboard, UserService 조립하기
 + 업무로직을 처리하는 클래스 UserService에 UserRepository 조립하기
 + 데이터 영속화를 담당하는 클래스 UserRepository에 List<User> 조립하기

5. 사용자와 상호작용하는 클래스에 메뉴 출력기능 구현하기
 +  UserApp 클래스에 showMenu 기능 구현하기

6. 메뉴에 맞는 사용자와 상호작용하는 메소드 정의하기
    UserApp 클래스에 전체조회, 조회, 등록, 수정, 삭제, 종료 기능 구현하기

7. 사용자 등록 기능 구현하기 [ 작업을 구현하려면 최소 3개의 클래스는 작성해야 한다. ]

   UserApp 클래스의 등록() 메소드 
  - 키보드로 아이디, 이름, 이메일, 전화번호를 입력받는다.
  - 입력된 사용자 정보를 User 객체를 생성해서 담는다.
  - 사용자 정보가 담긴 User 객체를 서비스에 전달해서 등록시킨다.

   UserService 클래스의 addNewUser(User user)메소드 [ 유저를 전달받는다. ]
  - 매개변수로 신규 사용자정보를 전달받아야 한다.
  - 사용자 아이디로 사용자 정보를 조회한다.
    * 사용자 정보가 존재하면 아이디 중복 오류를 발생시킨다.
  - 신규 사용자 정보를 전달받아서 레포지토리에 전달해서 저장시킨다.
  
   UserRepository 클래스의 save(User user) 메소드
  - 매개변수로 신규 사용자정보를 전달받아야 한다.
  - 신규 사용자정보를 전달받아서 콜렉션에 저장시킨다.

   UserRepository 클래스의 User findUserById(String id) 메소드
 - 매개변수로 조회할 사용자 아이디를 전달받아야 한다.
 - 사용자 아이디가 일치하는 사용자정보를 콜렉션에서 검색한다.
 - 검색된 사용자 정보를 반환한다.
 - 반환할 정보가 사용자 정보 하나기 때문에 반환타입은 User다.

3-tier 구조 : 클라이언트 - 서버 - 데이터베이스 
일반적으로 레포지토리 (영속화 계층)에는 업무 로직이 없고, 단순 작업이 있고
모든 업무 로직은 서비스에 구축해야 한다. [ 레포지토리에 전달되는 값은 모두 유효한 값이어야 함 ]

8. 전체 사용자정보 조회하기
	UserApp 
		전체조회() 메소드
			- 사용자 입력은 필요없다.
			- 서비스의 GetAllUsers() 메소드를 호출해서 전체 사용자 정보를 반환받는다.
			- 조회된 전체 사용자정보를 화면에 출력한다.
	UserService
		List<User> getAllUsers() 메소드
			- 매개변수로 값을 전달받을 필요가 없다.
			- 레파지토리의 findAll() 메소드를 호출해서 모든 사용자정보를 반환받는다.
			- 조회된 모든 사용자정보를 반환한다.
			- 반환할 정보가 사용자정보 여러개 이기 때문에 반환타입은 List<User>다.
	UserRepository
		List<User> findAll() 메소드
			- 매개변수로 값을 전달받을 필요가 없다.
			- 모든 사용자정보를 반환한다.


계층을 건너뛸 수 없음. ( 무조건 각각의 레이어는 지켜서 작성해야 함. ) 불편하더라도... ㅠ

메서드 작성 시 반환값을 
첫 줄에 기본값으로 설정하고
마지막줄에 기본값을 반환하도록 설정해두고 작성하자.

