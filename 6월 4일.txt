코드 없이 알고리즘 설명되어있는 책 같은 거 참고하면 도움됨.
[ 푸는 방법을 먼저 머리로 알아야, 코딩할 수 있음 ]

누구나 자료 구조와 알고리즘 - 길벗 

난수 - 실행할 때마다 다른 숫자가 나오는 것. 
난수 생성 메서드
( 0보다 크거나 같고 1보다 작은 실수값이 나옴 )

객체 지향 프로그래밍 
- 절차지향 프로그래밍을 보완한 프로그래밍 방식

장점 : 코드의 재사용성이 높다, 관리가 용이함....

객체 = 완성된 제품.
자바에서는 설계도를 먼저 만들어야 함.
[ 설계도만 있으면 제품을 만들어내기 쉬우니 코드의 재사용성이 높다 . ]

코드 = 클래스
제품 = 객체

객체지향에서는 상속이 가능함. [ 상속 = 물려받는 것 ]
[ 상속을 통해 기존의 설계도를 재사용해서 새로운 코드 작성이 편해진다. ]
[ = 코드의 재사용성이 높다. ]

클래스 단위로 작게 작게 쪼개져 있으니 관리도 용이하고, 확장도 쉬워진다.
객체들간의 관계를 느슨하게 연결해서 교체가 용이하게 한다.

객체 = 속성 ( 데이터 ) + 기능
객체는 공개된 기능만을 사용하여 그 객체를 다룰 수 있다.

반제품 상태의 객체를 만들고 느슨하게 결합시켜서 하나의 객체를 만들어나간다.

반제품 상태의 객체를 만드는 데 쓰이는 것 - 클래스.

부품에 해당하는 객체들을 만들고, 객체를 조립해서 소프트웨어를 만드는 개발방식.

캡슐화 : 객체의 실제 구현 내용을 감추는 것
[ 다른 객체는 객체의 내부구조를 알 수 없고, 공개된 속성과 기능만을 이용할 수 있음 ]
[ 목적 : 잘못된 사용으로 인한 객체의 손상 방지 - 객체의 안전한 사용을 위해 ]

상속 : 기존 클래스를 사용해서 새로운 클래스를 만드는 것
[ 상위 클래스를 재사용해서 하위 클래스를 빠르게 개발 가능 ]
[ 상위 클래스와 하위 클래스는 종속 관계를 형성함으로서 클래스들을 조직화 함 ]

다형성 : 객체지향 프로그래밍의 가장 중요한 특성
[ 같은 종류의 객체지만, 실행결과가 다양한 객체를 이용할 수 있는 성질 ]
[ 사용하는 방법은 동일하지만, 사용하는 객체가 바뀌면 결과가 다르게 발현되는 것 ]

객체 : 물리적으로 존재하거나 추상적으로 생각할 수 있는 개념 
[ 다른 것과 식별 가능한 것 ]
[ 모든 객체는 자신의 고유한 속성과 기능을 가짐. ]

속성 : 객체의 상태 [ 데이터 ]
기능 : 객체의 고유한 기능 

프로그램에서의 객체 : 클래스를 통해 메모리안에 생성된 것.

모델링 : 현실세계의 객체를 프로그래밍의 설계도로 만드는 것 

필드 : 객체의 속성, ' 클래스의 포함된 변수 ' 
[ 클래스나 객체의 속성을 나타내는 변수, 클래스 내부에 선언됨. ]

객체 간의 관계 
- 집합관계 ( 포함관계 ) : 객체가 다른 객체의 부품으로 사용되는 관계
- 사용관계 ( 의존관계 ) : 객체가 다른 객체의 기능을 사용하는 관계
- 상속관계 : 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계

클래스 : 자바에서 객체에 대한 설계도.

자바에서 객체를 instance, object, bean이라고 부른다
[ 그냥 그렇구나 하고 읽고 넘어가기 ]

인스턴스화 : 클래스로부터 객체를 생성하는 과정.

클래스의 설계
public class 클래스이름 {

}

main 메서드 - 애플리케이션의 진입점이 됨.
[ main 메서드는 객체 생성 없이 사용 가능한 기능임. ]

객체 생성방법 : new 클래스명();
[ new 연산자는 메모리의 힙영역에 객체를 생성한 후, 메모리 내에서 객체의 위치를
알 수 있도록 객체의 주소값을 반환한다. ]

수업에서는 메인이 있는 클래스명 뒤에 App를 붙인다.

메인 메서드가 있어야지만 실행이 가능하다....

// 객체 생성하기
/*
new 클래스명();
1. JVM이 클래스명에 해당하는 설계도를 메모리에 로딩한다. 
2. 설계도를 이용해서 메모리의 Heap 영역에 객체를 생성한다.
Heap 영역은 객체가 생성되는 영역이다.
Heap 영역은 가비지 콜렉터의 관리대상 영역이다.
3. 생성된 객체의 주소값(참조값)을 반환한다.
4. 참조변수를 생성하고, 참조변수에 생성된 객체의 주소값이 대입된다.
5. 참조변수는 참조값에 해당하는 객체를 참조한다.

해시코드를 사용하는 이유 - 객체들을 구별하기 위해서 

Car car1 = new Car(); 
Car car2 = new Car(); 
Car car3 = new Car();

// 얘네 3개는 동일한 설계도로 만들어진 서로 다른 객체를 참조함.

주소값을 획득하는 순간 객체를 바라봄.

클래스의 구성 요소 
1) 필드 : 객체의 데이터를 저장함.
2) 생성자 : 객체 생성 시 초기화 역할을 담당함
3) 메소드 : 객체의 기능에 해당하는 수행블록.

필드가 되려면 클래스 바로 아래에 만들어야 함.

객체를 만드는 건 나만의 그릇을 만드는 것임. 

c에서는 구조체로는 변수밖에 못 담았는데 자바에서는 객체를 이용해
변수 + 기능까지 구현할 수 있다.

클래스 내의 멤버에는 기본값이 이미 들어가 있음.

설계도로 객체를 만들면 해당 타입의 기본값으로 초기화 되어 있음.

이클립스 
클래스나 멤버 메서드를 정의한 곳으로 이동하려면 ctrl + 객체 클릭.

JavaDoc은 /** 별 2개 치고 입력하면 됨.
[ JavaDoc으로 해놓으면 마우스 커서 위로 올리면 이클립스를 통해 설명 볼 수 있음 ]

객체 배열의 각 요소인 참조변수는 heap에 생성된다. ( 객체배열이 heap에 생성됨 )

이클립스 우클릭 -> source -> generate toString
하면 객체 정보를 보여주는 toString을 자동 생성해줌...

변수명은 동적으로 변경하는 게 불가능하다.
[ booki 뭐 이런 거 안됨 ]

for ( Book x : books ) {
			
		}

// Book 타입 참조변수를 꺼낼 거니깐 Book을 꺼낼 그릇으로 선언한다.
Book 타입이어야 Book 객체의 주소값을 담을 수 있다.

Book a; 
: Book 설계도로 생성된 객체의 주소값을 담는 참조변수 a 생성.

머릿속으로 코드 진행 과정을 그릴수있어야함..

객체의 용도
1. 우리가 다루고자 하는 복합적인 정보를 담을 수 있는 객체를 위한 설계도
