이벤트 주도 개발

사용자(User)
- 애플리케이션과 상호작용하는 사람
- 상호작용 : 버튼클릭, 키보드입력, 체크박스 체크/해제, 메뉴 클릭 등

이벤트 소스(Event Source)
- 사용자와의 상호작용으로 이벤트를 발생시키는 컴포넌트
- 컴포넌트 : 버튼, 메뉴, 입력필드, 체크박스, 라디오버튼, 셀렉트박스 등

이벤트(Event)
- 사용자와 이벤트 소스의 상호작용의 결과로 이벤트 소스가 생성하는 것
- 이벤트 = 사용자와 상호작용한 이벤트 소스의 정보 + 상호작용의 종류

이벤트 리스너(Event Listener) 
- 이벤트 발생을 감지하고, 해당 이벤트 발생시 수행할 작업을 실행하는 것
- 이벤트 소스에 이벤트 리스너를 등록한다.
- 하나의 이벤트 소스에 상호작용의 종류별로 이벤트 리스너를 등록한다.
- 예)
   버튼(이벤트소스) <------- 이벤트리스너(이벤트 발생 시 수행할 작업)

                                     클릭[상호작용]
JMenuItem(이벤트소스)   <----------------  사용자

어떤 이벤트 소스의 어떤 상호작용을 실행할 지만 이벤트 리스너로 정의하면
GUI가 알아서 실행함.

클래스로 추상화하기보다는 인터페이스로 추상화하는 게 나은 이유.
[ 클래스는 단일 상속이지만 다중 상속을 이용할 수 있음. ] 

추상화된 메소드가 많은 인터페이스로 익명 객체를 정의하게 되면 실제로 재정의할 필요가 없는
추상 메소드를 전부 재정의해야 한다.

추상화된 메소드가 멍텅구리 구현된( 걍 구현부 {} 만 만든 ) 추상클래스를 이용해서 익명 객체를
정의하게 되면 실제로 재정의할 메소드만 구현하면 된다.

접근 제한자 - 클래스 내에서 멤버의 접근을 제한한다.
public, protected, private 등....

자바의 패키지 
- 관련있는 클래스를 담는 컨테이너 역할을 한다.
- 자바의 패키지는 파일스시템의 폴더로 생성된다.

- 역할 
 + 관련있는 클래스를 패키지별로 분류해 놓기 때문에 쉽게 클래스를 찾을 수 있다.
 + 동일한 이름의 클래스를 구별할 수 있다.
      java.util.Date와 java.sql.Date는 클래스 이름은 동일하지만 패키명이 서로 다르기 때문에 
     구분할 수 있다.
 + 접근 제한자를 이용해서 접근을 제한할 수 있다.
   public : 같은 패키지 및 다른 패키지의 클래스에서 접근 가능
   protected : 같은 패키지 및 다른 패키지의 자식 클래스에서 접근 가능
   default: 같은 패키지의 클래스에서 접근 가능

- 패키지의 정의 
   + 패키지 이름은 .으로 구분된 계층적 구조를 가진다.
      예 ) 패키지명 -> study.oop.demo1
                        study 패키지가 최상위 패키지
                        oop 패키지는 study 패키지의 하위 패키지
                        demo1 패키지는 oop 패키지의 하위 패키지
                        demo2 패키지는 oop 패키지의 하위 패키지
   + 패키지 이름은 디렉토리 구조와 동일한 구조를 가진다.
   예 ) 패키지명 -> study.oop.demo1
         디렉토리 -> study 폴더 > oop 폴더 > demo1 폴더
   + 패키지 이름은 도메인 네임을 거꾸로 뒤집은 형태를 가진다.
    [ 회사의 도메인 이름을 거꾸로해서 패키지 이름을 짓는다. ]
    [ 반드시 다른 이름으로 패키지 이름을 짓기 위해서. ]
    [ 도메인 이름은 전세계에서 유일한 이름으로 존재 가능 ]
        예 ) kr.co.jhta.shop.user
              kr.co.jhta.shop.goods
              kr.co.jhta.shop.board

- 패키지의 활용
    + 특정 패키지에 소속된 클래스로 정의할 수 있다.
     예)
     package 패키지명; 
     public class Sample {} 
     -> Sample 클래스는 package 키워드로 정의한 패키지에 포함된다.
     * package 구문의 설계도의 맨 처음에 위치해야 한다.
 + 다른 패키지에 정의한 클래스를 사용할 수 있다.
     예)
     package demo1;
     public class Sample2{ }

     package demo2;
     import demo1.Sample1; // demo1 패키지의 Sample1 클래스를 사용할 수 있게 한다.

    public class Sample2{
    }

   * Sample2 클래스에서 다른 패키지에 정의된 Sample1 클래스를 사용하기 위해서는
   import 구문으로 패키지명과 사용할 클래스를 지정해야 한다.
  * 단, java.lang 패키지에 정의된 클래스는 import 구문 없이 사용가능하다.
  * import 방법
       	패키지명과 클래스명을 지정하는 방법
		import demo2.Sample1; // demo2 패키지의 Sample1 클래스만 import
	패키지명과 와일드카드(전부 다)로 지정하는 방법
      		import demo2.*; // demo2 패키지의 모든 클래스를 import 한다.
		( 와일드카드는 해당 패키지의 클래스만 import한다. )
              	( 해당 패키지의 하위 패키지의 클래스는 import 하지 않는다. )
	패키지명이 다르고 클래스명이 같은 클래스를 import 하는 경우
		import java.util.Date;
		public class Sample {
			Date createDate;
			Date updateDate;
			java.sql.Date birth = new java.sql.Date(); // 다른 애는 패키지명까지 명시 
		}
		* 클래스명이 같은 클래스를 동시에 import 할 수 없다.
		* 사용빈도가 많은 클래스를 import문에 적고, 해당 클래스는 패키지명 없이 사용
		* 사용빈도가 적은 클래스는 import에 적지 않고, 사용할 때마다 명시해줘야 함.
- 주의
  import java.util.Date;  
  import java.sql.Date; 
이름 같은 클래스 2개를 동시 import는 불가.
[ 이런 경우에는 1개는 import 하고, 다른 1개는 패키지명까지 명시해줘야 함. ]

클래스 - public, default만 가능
멤버변수, 정적변수, 생성자, 멤버 메소드, 정적 메소드 - 다 가능
지역 변수 - 접근 제어자 불가능.

접근 제한이 걸리면 import도 불가능, 자동 완성도 불가능

자식 클래스에서는 객체 생성 없이 속성과 기능을 물려 받은 걸 바로 사용할 수 있다.
[ 그러나, 상속을 받아도 접근 제한 규칙은 자식 클래스에서도 적용된다. ]

싱글톤 객체 - 애플리케이션이 실행되는 동안 그 설계도로 만든 객체는 한 개여야만 하는 것.
[ 하나만 있어도 되는 객체 ]
정보를 담는 객체 - 정보의 개수만큼 있어야 함.
[ 객체 생성을 못하게 하려면 생성자에 접근을 못하게 해야 됨 . ]

- 싱글턴 객체가 되는 방법 
	 *   1. 생성자 메소드의 접근 제한을 private으로 한다.
	 *   2. 객체를 생성해서 정적 변수에 대입한다.
	 *   	정적 변수를 이용하면 ★ 설계도 로딩시에 객체 생성 ★ 되어서
	 *   	정적변수에 대입된다.
	 *   3. 2번에 생성한 객체를 제공하는 정적 메소드를 작성한다.
	 *   4. 이 객체가 필요한 경우 3번 정적 메소드를 실행해서
	 *   	2번 시점에 미리 생성해 둔 객체를 반환받아서 사용한다.
- 싱글턴 객체의 getInstance()는 항상 같은 객체의 주소값이 반환된다.

예시)
public class SingletonSample {

	private static SingletonSample instance = new SingletonSample();
	
	public static SingletonSample getInstance() {
		return instance; 
	}
}

import문에 적는 건 로딩과는 상관없음. 실제 소스코드에 적냐 안 적냐가 중요.

메소드도 private으로 은닉화 가능하지만, 드뭄.

캡슐화(=은닉화) : 사용자에게 공개할 필요가 없는 속성과 기능을 은닉화시킴.
접근제한자를 이용한 은닉을 기본 전제로 함.

캡슐화의 목적 - 객체의 데이터를 보호할 수 있다. 사용자 편의성이 높아진다.
                      유지보수성이 좋아진다.

☆ 정리


○ 클래스 - 객체를 생성하기 위한 설계도
    객체 - 설계도를 이용해서 메모리에 생성된 것.

○ 클래스 구성 요소
  필드 - 객체의 상태, 정보를 저장
  생성자 - 객체 생성직후에 수행할 작업을 정의하는 메소드, 초기화 작업을 담당하는 메소드
  메소드 - 객체의 고유한 기능을 제공
  * 클래스는 단지 설계도에 불과하다.
  * 값을 저장하고 기능을 실행하기 위해서는 반드시 설계도로 객체를 생성한 다음에만 가능하다.
  [ 정적 메소드 , 정적 변수 제외 ]

○ 객체 생성하고 사용하기
   Sample s1 = new Sample();
   * new 키워드는 Sample 설계도를 메모리에 로딩시키고, 설계도로 객체를 생성한다.
   * 객체가 생성되면 생성자 메소드는 자동으로 실행된다. 
     인자값에 맞는 매개변수를 가진 생성자 메소드가 실행된다.
   * new 키워드는 생성된 객체의 주소값을 참조변수 s1에 대입시킨다.

   s1.test();
   * 생성된 객체의 속성(멤버변수)와 기능(메소드)를 이용하기 위해서는 언제나 참조변수가 필요하다.
   * 참조변수 s1의 생성된 객체를 참조하는 주소값을 가지고 있다.

○ 메소드
   * 객체의 고유한 기능을 담당한다.
   * 형식 
       선언부 : 접근제한자 반환타입 메소드명(타입 변수, 타입 변수)
       바디부 : { 
                      수행문;
                      수행문;
                   }
      * 단, 추상화된 메소드는 바디부가 없이 만든다.
    * 메소드 구현절차 
	1. 구현 요구사항을 파악한다.
	   - 입력값과 최종 출력값을 파악한다. [ 매개변수와 반환타입 파악하기 ]
	    * 정보 조회, 계산 결과 제공은 반환타입이 void가 아니다.
                  * 정보를 추가, 삭제, 변경하는 작업은 반환타입이 대부분 void다.
	   - 제시된 조건을 파악한다. [ 수행문 작성에 필요한 조건을 결정한다. ] 
         	 2. 반환타입, 매개변수, 메소드명을 결정하고 메소드의 선언부를 작성한다.
  	   - 메소드명은 동사형으로 작성한다.
                 - 해당 메소드가 제공하는 기능을 잘 드러내는 이름으로 짓는다.
               3. 제시된 조건을 적용해서 바디부에 수행문을 구현한다.
 
